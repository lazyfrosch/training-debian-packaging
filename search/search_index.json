{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction What is Debian? Debian is a free and open source operating system. With no company behind it Debian is based on it's large community of Debian Developers and Maintainers. Some companies let their employees actively contribute to Debian with the idea of building an operating system, that can be used for the company, and/or customers. Debian has multiple derivatives , the most well known is Ubuntu , which builds most of it's core on Debian, but changes a lot in terms of Installation and Desktop experience. Purpose of this training This training is meant to give you an overview about how Debian packages and repositories work. You should already have basic knowledge about: Linux CLI (and Desktop) Bash Scripting Things you will learn: TODO Start reading Admin Guide - How to use packages and add new repositories Developer Guide - How to (re-)build packages","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#what-is-debian","text":"Debian is a free and open source operating system. With no company behind it Debian is based on it's large community of Debian Developers and Maintainers. Some companies let their employees actively contribute to Debian with the idea of building an operating system, that can be used for the company, and/or customers. Debian has multiple derivatives , the most well known is Ubuntu , which builds most of it's core on Debian, but changes a lot in terms of Installation and Desktop experience.","title":"What is Debian?"},{"location":"#purpose-of-this-training","text":"This training is meant to give you an overview about how Debian packages and repositories work. You should already have basic knowledge about: Linux CLI (and Desktop) Bash Scripting Things you will learn: TODO","title":"Purpose of this training"},{"location":"#start-reading","text":"Admin Guide - How to use packages and add new repositories Developer Guide - How to (re-)build packages","title":"Start reading"},{"location":"about/license/","text":"License Copyright (c) 2018-2021 NETWAYS GmbH info@netways.de Material is licensed under CC-BY-SA-4.0 . You can find the source code on GitHub .","title":"License"},{"location":"about/license/#license","text":"Copyright (c) 2018-2021 NETWAYS GmbH info@netways.de Material is licensed under CC-BY-SA-4.0 . You can find the source code on GitHub .","title":"License"},{"location":"about/references/","text":"References There are multiple sources in terms of deeper documentation and further reading on packaging for Debian. Debian Developer Manuals Best Packaging Practices Maintainer Guide Building Guide Books Debian Handbook Some handbooks are also available in other languages, check the overview page.","title":"References"},{"location":"about/references/#references","text":"There are multiple sources in terms of deeper documentation and further reading on packaging for Debian. Debian Developer Manuals Best Packaging Practices Maintainer Guide Building Guide Books Debian Handbook Some handbooks are also available in other languages, check the overview page.","title":"References"},{"location":"admin/","text":"CLI Tools There are various CLI tools to interact with packages in Debian, either for installing, upgrading, removing, or to interact in more detail with them APT vs. DPKG The major difference in packaging lies between the purpose of APT and DPKG . DPKG is the low-lever package manager that takes care about: Validating and unpacking a package archive Dependencies File ownership Consistency Configuring the package Writing or updating config files Starting / controlling services Custom scripts APT is the main user-CLI interface to work with, it will help you: Downloading repository meta-data and validating signatures Downloading and installing packages Resolving all dependencies and including them in any action Updating all packages on your system Removing and cleaning up after packages Under the hood APT will control DPKG to execute all actions in the proper order. Summary: Use APT for the daily business, only touch dpkg when something special needs to be done. APT Tools The APT package manager currently has 3 major interfaces. apt which is the simplest CLI tools that offers most of the actions in one binary aptitude offers a CLI based UI to search and manipulate packages on your system apt- * additional APT binaries that are the legacy interface (like apt-get or apt-cache ) Other graphical interfaces also exist, but we keep working on the command-line here. Learning by example To learn the basics, just try to execute the examples, and follow whats happening on your test system. Update cache APT has a local cache for all meta-data, this needs to be current so APT knows all packages and can determine what is needs to be updated. Sometimes this is run automatically in background, but by default on a basic system, it is not. sudo apt update You should see: Meta data being checked and downloaded from repositories Rebuilding of package indices Count of packages that can be updated Searching and inspecting You can search the package meta data, with description, regexp or just the package names: sudo apt search archimedes constant sudo apt search \"^pi$\" sudo apt search --names-only icinga2 You should see: Listings of known packages matching your search To inspect a package in more detail you can use the show command: sudo apt show pi sudo apt show icinga2 You should see: Version and Description Dependencies Maintainer Various other meta data Install a package To install a package with all its dependencies you just need to run: sudo apt install pi If dependencies need to be installed, APT will ask you about it. You should see: APT downloading the package from a remote server Installing the packages in the proper order Output after downloading is mainly generated by DPKG, which is doing the local work Listing packages You can list packages with some filter, for example installed packages, or those available for update. sudo apt list --installed sudo apt list --upgradable Update your system To update your system there are two slightly different commands: sudo apt upgrade sudo apt full-upgrade upgrade is called the safe upgrade, meaning it will update packages while possibly install new dependencies, but never remove anything. full-upgrade or dist-upgrade was mainly used for running major distribution updates, but it can be used anytime This will in addition to upgrading, also remove obsolete or no longer compatible packages But no matter which command you use, it will always show you what will be done, and wait for a confirmation. Cleaning up cache After larger updates you can cleanup cached downloads of APT: sudo apt autoclean sudo apt clean Question: What is the difference between those commands? See man apt-get Removing no longer used packages APT can also help you remove no longer needed packages. It knows which packages have been installed manually (by user action), and those who were installed for dependency. sudo apt remove pi sudo apt autoremove You should see: APT will give you a notice about no longer required packages on apt remove pi autoremove will then uninstall the packages after confirmation Purging packages To completely remove a package and its data, you should purge it instead of remove. This will ensure config and possible other data in /var will also be removed, also very helpful for reinstalling a package for a fresh start. sudo apt purge pi sudo apt remove --purge pi Also check dpkg -L <package> after removing a package to see left over files from the package. APT History A full log of actions with APT is stored in /var/log/apt/history.log . Start-Date: 2021-04-08 13:54:28 Commandline: apt install finger Requested-By: user (1000) Install: finger:amd64 (0.17-17) End-Date: 2021-04-08 13:54:31 This will keep details on installs, upgrades, or any other action for up to 12 months. See /etc/logrotate.d/apt to change rotation settings. Configuration files DPKG remembers all files installed to /etc as config files, it can ask you if you want to keep your changes or replace the content on an upgrade. Upgrade will store the new config as .dpkg-new or the old version as .dpkg-old , depending on your choice. When a user removed a configuration file completely, it won't be put back, unless you purge and re-install the package. Inspecting with DPKG DPKG can also give you information about packages that have ever been installed on the local system, or names DPKG has seen in dependencies: dpkg -l dpkg -l pi dpkg -l \"lib*\" You can see the contents of a package: dpkg -L bash Or see which package a file belongs to: dpkg -S /usr/bin/apt Online Resources Debian has web tools to search for packages or bugs in them. Package Search or on packages.d.o Bug Tracker or bugs.d.o which is the general issue tracker Security Tracker to search and review security issues by release News on the website Mailing lists debian-announce debian-security-announce debian-stable-announce debian-lts-announce other user lists Further documentation man apt man dpkg man apt-get man apt-cache","title":"CLI Tools"},{"location":"admin/#cli-tools","text":"There are various CLI tools to interact with packages in Debian, either for installing, upgrading, removing, or to interact in more detail with them","title":"CLI Tools"},{"location":"admin/#apt-vs-dpkg","text":"The major difference in packaging lies between the purpose of APT and DPKG . DPKG is the low-lever package manager that takes care about: Validating and unpacking a package archive Dependencies File ownership Consistency Configuring the package Writing or updating config files Starting / controlling services Custom scripts APT is the main user-CLI interface to work with, it will help you: Downloading repository meta-data and validating signatures Downloading and installing packages Resolving all dependencies and including them in any action Updating all packages on your system Removing and cleaning up after packages Under the hood APT will control DPKG to execute all actions in the proper order. Summary: Use APT for the daily business, only touch dpkg when something special needs to be done.","title":"APT vs. DPKG"},{"location":"admin/#apt-tools","text":"The APT package manager currently has 3 major interfaces. apt which is the simplest CLI tools that offers most of the actions in one binary aptitude offers a CLI based UI to search and manipulate packages on your system apt- * additional APT binaries that are the legacy interface (like apt-get or apt-cache ) Other graphical interfaces also exist, but we keep working on the command-line here.","title":"APT Tools"},{"location":"admin/#learning-by-example","text":"To learn the basics, just try to execute the examples, and follow whats happening on your test system.","title":"Learning by example"},{"location":"admin/#update-cache","text":"APT has a local cache for all meta-data, this needs to be current so APT knows all packages and can determine what is needs to be updated. Sometimes this is run automatically in background, but by default on a basic system, it is not. sudo apt update You should see: Meta data being checked and downloaded from repositories Rebuilding of package indices Count of packages that can be updated","title":"Update cache"},{"location":"admin/#searching-and-inspecting","text":"You can search the package meta data, with description, regexp or just the package names: sudo apt search archimedes constant sudo apt search \"^pi$\" sudo apt search --names-only icinga2 You should see: Listings of known packages matching your search To inspect a package in more detail you can use the show command: sudo apt show pi sudo apt show icinga2 You should see: Version and Description Dependencies Maintainer Various other meta data","title":"Searching and inspecting"},{"location":"admin/#install-a-package","text":"To install a package with all its dependencies you just need to run: sudo apt install pi If dependencies need to be installed, APT will ask you about it. You should see: APT downloading the package from a remote server Installing the packages in the proper order Output after downloading is mainly generated by DPKG, which is doing the local work","title":"Install a package"},{"location":"admin/#listing-packages","text":"You can list packages with some filter, for example installed packages, or those available for update. sudo apt list --installed sudo apt list --upgradable","title":"Listing packages"},{"location":"admin/#update-your-system","text":"To update your system there are two slightly different commands: sudo apt upgrade sudo apt full-upgrade upgrade is called the safe upgrade, meaning it will update packages while possibly install new dependencies, but never remove anything. full-upgrade or dist-upgrade was mainly used for running major distribution updates, but it can be used anytime This will in addition to upgrading, also remove obsolete or no longer compatible packages But no matter which command you use, it will always show you what will be done, and wait for a confirmation.","title":"Update your system"},{"location":"admin/#cleaning-up-cache","text":"After larger updates you can cleanup cached downloads of APT: sudo apt autoclean sudo apt clean Question: What is the difference between those commands? See man apt-get","title":"Cleaning up cache"},{"location":"admin/#removing-no-longer-used-packages","text":"APT can also help you remove no longer needed packages. It knows which packages have been installed manually (by user action), and those who were installed for dependency. sudo apt remove pi sudo apt autoremove You should see: APT will give you a notice about no longer required packages on apt remove pi autoremove will then uninstall the packages after confirmation","title":"Removing no longer used packages"},{"location":"admin/#purging-packages","text":"To completely remove a package and its data, you should purge it instead of remove. This will ensure config and possible other data in /var will also be removed, also very helpful for reinstalling a package for a fresh start. sudo apt purge pi sudo apt remove --purge pi Also check dpkg -L <package> after removing a package to see left over files from the package.","title":"Purging packages"},{"location":"admin/#apt-history","text":"A full log of actions with APT is stored in /var/log/apt/history.log . Start-Date: 2021-04-08 13:54:28 Commandline: apt install finger Requested-By: user (1000) Install: finger:amd64 (0.17-17) End-Date: 2021-04-08 13:54:31 This will keep details on installs, upgrades, or any other action for up to 12 months. See /etc/logrotate.d/apt to change rotation settings.","title":"APT History"},{"location":"admin/#configuration-files","text":"DPKG remembers all files installed to /etc as config files, it can ask you if you want to keep your changes or replace the content on an upgrade. Upgrade will store the new config as .dpkg-new or the old version as .dpkg-old , depending on your choice. When a user removed a configuration file completely, it won't be put back, unless you purge and re-install the package.","title":"Configuration files"},{"location":"admin/#inspecting-with-dpkg","text":"DPKG can also give you information about packages that have ever been installed on the local system, or names DPKG has seen in dependencies: dpkg -l dpkg -l pi dpkg -l \"lib*\" You can see the contents of a package: dpkg -L bash Or see which package a file belongs to: dpkg -S /usr/bin/apt","title":"Inspecting with DPKG"},{"location":"admin/#online-resources","text":"Debian has web tools to search for packages or bugs in them. Package Search or on packages.d.o Bug Tracker or bugs.d.o which is the general issue tracker Security Tracker to search and review security issues by release News on the website Mailing lists debian-announce debian-security-announce debian-stable-announce debian-lts-announce other user lists","title":"Online Resources"},{"location":"admin/#further-documentation","text":"man apt man dpkg man apt-get man apt-cache","title":"Further documentation"},{"location":"admin/repositories/","text":"APT Repositories All packages APT downloads and installs are coming from APT repositories. Key Management and Security For security and trust purposes all repositories should be signed with a GPG key. This building a trust chain, where the administrator needs to add the public key to the local trust store, so that all meta data and packages downloaded can be verified against that trust store. apt-key list You should see: Keyrings installed by packages (e.g. /etc/apt/trusted.gpg.d/debian-archive-stretch-stable.gpg ) Optional keys in the local trust store /etc/apt/trusted.gpg You can also inspect the keyring packages: dpkg -l \"*keyring*\" dpkg -L debian-archive-keyring Most repositories should offer a installation script, or direct instructions where to download and add the key. Here is the Icinga example for Debian : wget -O - https://packages.icinga.com/icinga.key | sudo apt-key add - # or curl https://packages.icinga.com/icinga.key | sudo apt-key add - Note: In contrast to RPM packages, Debian packages are not individually signed, the repository is signed. Configured repositories Active repositories are configured inside /etc/apt in two ways: sources.list will contain the basic repositories for your Debian system sources.list.d/*.list can provide additional repositories Note: Please do not add custom repositories to sources.list , add a new file. Example of a default sources.list : deb http://deb.debian.org/debian stretch main deb http://security.debian.org/debian-security stretch/updates main deb http://deb.debian.org/debian stretch-updates main Syntax of the lines: deb (binary packages) or deb-src (source packages) URL to access the repository Release (or suite) Components of the repository (e.g. main non-free contrib ) To add a custom repository you can just add a new file: sudo vim /etc/apt/sources.list.d/icinga.list deb http://packages.icinga.com/debian icinga-stretch main deb-src http://packages.icinga.com/debian icinga-stretch main sudo apt update sudo apt show icinga2 Repositories can also be in \"simple\" Format: deb file:///tmp/debian ./ Repository layout This is a pretty complex topic, so we are just touching the basics. Each repository has a base URL: https://deb.debian.org/debian , this URL can be a CDN, or a local mirror of the repository (e.g. http://ftp.de.debian.org/debian/ ). On the repository any additional file can exist, what APT is looking for is this directory structure: dists/ dists/<release>/ # release would be: stretch, stable, etc. dists/<release>/Release # main metadata and checksums for all files dists/<release>/Release.gpg # signature for the metadata dists/<release>/<component>/ # component would be: main, contrib, non-free dists/<release>/<component>/Contents-<arch>.gz # arch would be: amd64, i386 dists/<release>/<component>/binary-all/ # arch independent packages (no binary programs) dists/<release>/<component>/binary-<arch>/ dists/<release>/<component>/binary-*/Packages.gz # meta data for all packages included dists/<release>/<component>/source/Sources.gz # meta data for all source packages included Various other metadata is included in these directories and then references by other files. The main trust-root comes from Release.gpg , which signs Release , all other files are referenced by checksum from there. Outside of dists/ it is most common to put the actual packages into pool/ , the structure here depends on the repository software used, files are references by URL and checksum from the metadata. Task: Go to a repository and explore: http://ftp.de.debian.org/debian/dists/stretch/ http://ftp.de.debian.org/debian/pool/ Further reading man apt-secure man sources.list","title":"Repositories"},{"location":"admin/repositories/#apt-repositories","text":"All packages APT downloads and installs are coming from APT repositories.","title":"APT Repositories"},{"location":"admin/repositories/#key-management-and-security","text":"For security and trust purposes all repositories should be signed with a GPG key. This building a trust chain, where the administrator needs to add the public key to the local trust store, so that all meta data and packages downloaded can be verified against that trust store. apt-key list You should see: Keyrings installed by packages (e.g. /etc/apt/trusted.gpg.d/debian-archive-stretch-stable.gpg ) Optional keys in the local trust store /etc/apt/trusted.gpg You can also inspect the keyring packages: dpkg -l \"*keyring*\" dpkg -L debian-archive-keyring Most repositories should offer a installation script, or direct instructions where to download and add the key. Here is the Icinga example for Debian : wget -O - https://packages.icinga.com/icinga.key | sudo apt-key add - # or curl https://packages.icinga.com/icinga.key | sudo apt-key add - Note: In contrast to RPM packages, Debian packages are not individually signed, the repository is signed.","title":"Key Management and Security"},{"location":"admin/repositories/#configured-repositories","text":"Active repositories are configured inside /etc/apt in two ways: sources.list will contain the basic repositories for your Debian system sources.list.d/*.list can provide additional repositories Note: Please do not add custom repositories to sources.list , add a new file. Example of a default sources.list : deb http://deb.debian.org/debian stretch main deb http://security.debian.org/debian-security stretch/updates main deb http://deb.debian.org/debian stretch-updates main Syntax of the lines: deb (binary packages) or deb-src (source packages) URL to access the repository Release (or suite) Components of the repository (e.g. main non-free contrib ) To add a custom repository you can just add a new file: sudo vim /etc/apt/sources.list.d/icinga.list deb http://packages.icinga.com/debian icinga-stretch main deb-src http://packages.icinga.com/debian icinga-stretch main sudo apt update sudo apt show icinga2 Repositories can also be in \"simple\" Format: deb file:///tmp/debian ./","title":"Configured repositories"},{"location":"admin/repositories/#repository-layout","text":"This is a pretty complex topic, so we are just touching the basics. Each repository has a base URL: https://deb.debian.org/debian , this URL can be a CDN, or a local mirror of the repository (e.g. http://ftp.de.debian.org/debian/ ). On the repository any additional file can exist, what APT is looking for is this directory structure: dists/ dists/<release>/ # release would be: stretch, stable, etc. dists/<release>/Release # main metadata and checksums for all files dists/<release>/Release.gpg # signature for the metadata dists/<release>/<component>/ # component would be: main, contrib, non-free dists/<release>/<component>/Contents-<arch>.gz # arch would be: amd64, i386 dists/<release>/<component>/binary-all/ # arch independent packages (no binary programs) dists/<release>/<component>/binary-<arch>/ dists/<release>/<component>/binary-*/Packages.gz # meta data for all packages included dists/<release>/<component>/source/Sources.gz # meta data for all source packages included Various other metadata is included in these directories and then references by other files. The main trust-root comes from Release.gpg , which signs Release , all other files are referenced by checksum from there. Outside of dists/ it is most common to put the actual packages into pool/ , the structure here depends on the repository software used, files are references by URL and checksum from the metadata. Task: Go to a repository and explore: http://ftp.de.debian.org/debian/dists/stretch/ http://ftp.de.debian.org/debian/pool/","title":"Repository layout"},{"location":"admin/repositories/#further-reading","text":"man apt-secure man sources.list","title":"Further reading"},{"location":"dev/","text":"Development Environment Installing the basics To start development on packages you need to not install package specific dependencies, but also the general toolset for Debian packages. sudo apt install devscripts dpkg-dev build-essential dh-make debhelper devscripts Includes various CLI tools to work with and manipulate a source package, see the description for more details: apt show devscripts dpkg-dev Brings the dpkg-* tools to actually build and assemble the packages, this is installed automatically as dependency of devscripts . debhelper Since dpkg-dev only contains the very basic toolset, debhelper brings are lot of automation and simplification to the build process. And avoids you taking care about everything. Just look for dh_* manpages. build-essential Depends on the most basic build tools, like make or gcc , which you will need for the most Unix sources. dh-make An optional add-on for quick-starting Debian packages, so to have a basic boilerplate to start with packaging. Online Resources Various online resources exist to help you research and find details on packages. Tracker Central search and information base for source packages Including: history, versions, bugs, security info and links to sources and other tools Debian GitLab Please also see the online resources in the Admin Guide .","title":"Build Environment"},{"location":"dev/#development-environment","text":"","title":"Development Environment"},{"location":"dev/#installing-the-basics","text":"To start development on packages you need to not install package specific dependencies, but also the general toolset for Debian packages. sudo apt install devscripts dpkg-dev build-essential dh-make debhelper","title":"Installing the basics"},{"location":"dev/#devscripts","text":"Includes various CLI tools to work with and manipulate a source package, see the description for more details: apt show devscripts","title":"devscripts"},{"location":"dev/#dpkg-dev","text":"Brings the dpkg-* tools to actually build and assemble the packages, this is installed automatically as dependency of devscripts .","title":"dpkg-dev"},{"location":"dev/#debhelper","text":"Since dpkg-dev only contains the very basic toolset, debhelper brings are lot of automation and simplification to the build process. And avoids you taking care about everything. Just look for dh_* manpages.","title":"debhelper"},{"location":"dev/#build-essential","text":"Depends on the most basic build tools, like make or gcc , which you will need for the most Unix sources.","title":"build-essential"},{"location":"dev/#dh-make","text":"An optional add-on for quick-starting Debian packages, so to have a basic boilerplate to start with packaging.","title":"dh-make"},{"location":"dev/#online-resources","text":"Various online resources exist to help you research and find details on packages. Tracker Central search and information base for source packages Including: history, versions, bugs, security info and links to sources and other tools Debian GitLab Please also see the online resources in the Admin Guide .","title":"Online Resources"},{"location":"dev/building/","text":"Building packages In the source package chapter we learned what is inside a source. This chapter explains how to build a package. All building is done with tools around dpkg-buildpackage , for example there is debuild . Build requirements You can install the build dependencies via APT. This is helpful when you need to re-build a package or want to make small modifications. sudo apt build-dep icingaweb2 When there are different dependencies in the next package version, you either need to install them manually, or use advanced helpers like pbuilder-satisfydepends . (WARNING: This is meant for chroot builds) Build a package Since we already have a source tree we can just build the current package: debuild Every build cleans up the build tree to start the build from scratch. Lab: Let's run the build and check the build log about what is happening. Bonus: Add export DH_VERBOSE=1 to the top of rules to have a detailed log Build output After the build certain files are created in the parent directory. <package>*_<version>.deb - the Debian binary packages Files as describes in Source Package <source>_<version>_<arch>.changes Metadata for the finished build and upload <source>_<version>_<arch>.build Log of the build <source>_<version>_<arch>.buildinfo Extended metadata for the build Inspecting build Inside the source tree you will find the typical build artifacts and binaries like in a normal sourcecode build. But also inside the debian/ directory, you will find new files and directories: tmp/ - temporary file tree installed by dh_auto_install <package>/ - file tree for every package <package>.substvars - replacement variables for control <package>.debhelper.log - log which debhelper tools have been run for this package Also the built binary package files can be inspected and even extracted without actually installing them by using dpkg-deb . dpkg-deb -c icingacli_2.6.1-1_all.deb dpkg-deb -I icingacli_2.6.1-1_all.deb mkdir test/ dpkg-deb -R icingacli_2.6.1-1_all.deb test/ Lab: Browse the directories under debian/ and have a look inside the built binaries Update changelog After changing packaging you always have to record that in changelog . It not only defines the version, but should contain useful short information about what was done. Every changelog entry contains: Source packages Version Target distribution (you will mostly see unstable and experimental here - UNRELEASED is for an incomplete changelog) Update priority (used for repository management in Debian) List of changes in text form Line signature with timestamp, developer name and e-mail To make this simple tools like dch and gbp-dch help. dch # spawns an editor dch -a \"I changed feature X\" # adds a new line to the current entry dch -v 1.1.0-1 \"Updated to 1.1.0\" # make a new release version You can always manually edit the file, as long as you keep the basic format. Signing and changes When a build is finished the .dsc and .changes files will be signed by a developer. Those file contains checksums for all included files. With upload tools like dput-ng the changes and all dependent files can be uploaded to a repository. Most repositories build trust on the signature and will apply a certain release mechanism.","title":"Building Packages"},{"location":"dev/building/#building-packages","text":"In the source package chapter we learned what is inside a source. This chapter explains how to build a package. All building is done with tools around dpkg-buildpackage , for example there is debuild .","title":"Building packages"},{"location":"dev/building/#build-requirements","text":"You can install the build dependencies via APT. This is helpful when you need to re-build a package or want to make small modifications. sudo apt build-dep icingaweb2 When there are different dependencies in the next package version, you either need to install them manually, or use advanced helpers like pbuilder-satisfydepends . (WARNING: This is meant for chroot builds)","title":"Build requirements"},{"location":"dev/building/#build-a-package","text":"Since we already have a source tree we can just build the current package: debuild Every build cleans up the build tree to start the build from scratch. Lab: Let's run the build and check the build log about what is happening. Bonus: Add export DH_VERBOSE=1 to the top of rules to have a detailed log","title":"Build a package"},{"location":"dev/building/#build-output","text":"After the build certain files are created in the parent directory. <package>*_<version>.deb - the Debian binary packages Files as describes in Source Package <source>_<version>_<arch>.changes Metadata for the finished build and upload <source>_<version>_<arch>.build Log of the build <source>_<version>_<arch>.buildinfo Extended metadata for the build","title":"Build output"},{"location":"dev/building/#inspecting-build","text":"Inside the source tree you will find the typical build artifacts and binaries like in a normal sourcecode build. But also inside the debian/ directory, you will find new files and directories: tmp/ - temporary file tree installed by dh_auto_install <package>/ - file tree for every package <package>.substvars - replacement variables for control <package>.debhelper.log - log which debhelper tools have been run for this package Also the built binary package files can be inspected and even extracted without actually installing them by using dpkg-deb . dpkg-deb -c icingacli_2.6.1-1_all.deb dpkg-deb -I icingacli_2.6.1-1_all.deb mkdir test/ dpkg-deb -R icingacli_2.6.1-1_all.deb test/ Lab: Browse the directories under debian/ and have a look inside the built binaries","title":"Inspecting build"},{"location":"dev/building/#update-changelog","text":"After changing packaging you always have to record that in changelog . It not only defines the version, but should contain useful short information about what was done. Every changelog entry contains: Source packages Version Target distribution (you will mostly see unstable and experimental here - UNRELEASED is for an incomplete changelog) Update priority (used for repository management in Debian) List of changes in text form Line signature with timestamp, developer name and e-mail To make this simple tools like dch and gbp-dch help. dch # spawns an editor dch -a \"I changed feature X\" # adds a new line to the current entry dch -v 1.1.0-1 \"Updated to 1.1.0\" # make a new release version You can always manually edit the file, as long as you keep the basic format.","title":"Update changelog"},{"location":"dev/building/#signing-and-changes","text":"When a build is finished the .dsc and .changes files will be signed by a developer. Those file contains checksums for all included files. With upload tools like dput-ng the changes and all dependent files can be uploaded to a repository. Most repositories build trust on the signature and will apply a certain release mechanism.","title":"Signing and changes"},{"location":"dev/dh_make/","text":"Using dh_make dh_make is a tool for quick-starting a new package. Extract sourcecode First you need to get and extract the original source code of your software. $ wget https://github.com/Icinga/icingaweb2/archive/v2.6.2.tar.gz $ tar xf v2.6.2.tar.gz $ mv icingaweb2-2.6.2 icingaweb2 Basically the extracted source tree can be named however you like, it is recommended to be either: source package name, without any version, like icingaweb2 source package with version, in format <source>_<upstreamversion> , e.g. icingaweb2_2.6.2 (please note underscore) Now we switch to this directory and run dh_make : $ cd icingaweb2/ $ dh_make -p icingaweb2_2.6.2 -f ../v2.6.2.tar.gz -p is necessary once here, when the directory is not in the <source>_<upstreamversion> format -f tells dh_make where to find the original tarball This leaves you with a collection of defaults and examples: $ ls -R debian/ debian/: changelog copyright icingaweb2-docs.docs manpage.xml.ex postrm.ex README.Debian source compat icingaweb2.cron.d.ex manpage.1.ex menu.ex preinst.ex README.source watch.ex control icingaweb2.doc-base.EX manpage.sgml.ex postinst.ex prerm.ex rules debian/source: format You should now browse the files and fill them with your information, and cleanup files you don't need! In addition dh_make will copy the tarball to the .orig.tar.gz filename for Debian: $ ls ../ icingaweb2 icingaweb2_2.6.2.orig.tar.gz v2.6.2.tar.gz Native packages dh_make can also get you started with native packages, so no original tarball exists. This is mainly useful when the debian/ directory will be included in the original sourcecode. $ dh_make --native -p icingaweb2_2.6.2","title":"Using dh_make"},{"location":"dev/dh_make/#using-dh_make","text":"dh_make is a tool for quick-starting a new package.","title":"Using dh_make"},{"location":"dev/dh_make/#extract-sourcecode","text":"First you need to get and extract the original source code of your software. $ wget https://github.com/Icinga/icingaweb2/archive/v2.6.2.tar.gz $ tar xf v2.6.2.tar.gz $ mv icingaweb2-2.6.2 icingaweb2 Basically the extracted source tree can be named however you like, it is recommended to be either: source package name, without any version, like icingaweb2 source package with version, in format <source>_<upstreamversion> , e.g. icingaweb2_2.6.2 (please note underscore) Now we switch to this directory and run dh_make : $ cd icingaweb2/ $ dh_make -p icingaweb2_2.6.2 -f ../v2.6.2.tar.gz -p is necessary once here, when the directory is not in the <source>_<upstreamversion> format -f tells dh_make where to find the original tarball This leaves you with a collection of defaults and examples: $ ls -R debian/ debian/: changelog copyright icingaweb2-docs.docs manpage.xml.ex postrm.ex README.Debian source compat icingaweb2.cron.d.ex manpage.1.ex menu.ex preinst.ex README.source watch.ex control icingaweb2.doc-base.EX manpage.sgml.ex postinst.ex prerm.ex rules debian/source: format You should now browse the files and fill them with your information, and cleanup files you don't need! In addition dh_make will copy the tarball to the .orig.tar.gz filename for Debian: $ ls ../ icingaweb2 icingaweb2_2.6.2.orig.tar.gz v2.6.2.tar.gz","title":"Extract sourcecode"},{"location":"dev/dh_make/#native-packages","text":"dh_make can also get you started with native packages, so no original tarball exists. This is mainly useful when the debian/ directory will be included in the original sourcecode. $ dh_make --native -p icingaweb2_2.6.2","title":"Native packages"},{"location":"dev/gbp/","text":"git-buildpackage Most modern Debian packages are managed with GIT repositories, where at least the packaging is versioned in GIT, and releases are usually also marked by GIT tags. Salsa A while ago Debian established GitLab as a central hosting service for all GIT repositories. The service is just named Salsa, and is available to everyone to join and contribute. salsa.debian.org Repository layouts Simple layout A simple GIT repositories will just contain the debian directory, plus maybe some CI and metadata to build with. In this mode you should find a very simple master or debian/master branch, can just clone it via git . But you will need to take care of downloading and extracting source code. This is also used for the Linux Kernel package , which only does a simple layout, because it is easier to handle in terms of repository sizes. Upstream branches Many other repositories include the full source code of the upstream project, so it is easier for a developer to have a full working environment. In this usage case, the upstream source code is imported under branch upstream , or even the original upstream GIT repository is used as base, with its branches like master . When importing upstream releases, GIT changes will only show a single commit for the version, with added GIT tag. To have the full file tree, there also will be a debian/master or master branch, which includes the debian directory. Upstream changes are then merged to the Debian packaging branch. As a result, after a GIT clone, you can just start building, and all file changes can be diffed against GIT. The icingaweb2 package repository is a good example for this usage style. pristine-tar As optional add-on you often find a pristine-tar branch, this branch is used to store metadata, so the original tarball can be recreated from the GIT branches. Please see man pristine-tar for details. git-buildpackage Now Debian introduced a small toolkit to work with GIT repositories as source for Debian packages, helping with tasks like: Cloning a GIT repository (with all gbp related branches) Pulling and pushing changes, across multiple branches Building the package while checking with GIT Updating changelog from GIT commits Importing / exporting tarballs of upstream When building a package with gbp , the upstream tarball is usually created automatically. Examples Cloning a repository: $ gbp clone https://salsa.debian.org/nagios-team/pkg-icingaweb2 icingaweb2 $ cd icinga2/ You will see that multiple branches have been checked out, and will be updated by pull: $ git branch $ gbp pull Building will create tarball and files in parent directory: $ gbp buildpackage -S $ ls ../icingaweb2* ../icingaweb2_2.7.3-2_amd64.build ../icingaweb2_2.7.3-2.debian.tar.xz ../icingaweb2_2.7.3-2.dsc ../icingaweb2_2.7.3.orig.tar.gz Note: When you want to build a specific version, you can just checkout the respective GIT tag or commit Updating the changelog is very easy with gbp: $ gbp dch -a $ git diff debian/changelog Building and changelog integration can also help with the release changelog, git commits and tags. Further reading gbp manual man gbp man gbp-buildpackage man gbp-dch","title":"git-buildpackage"},{"location":"dev/gbp/#git-buildpackage","text":"Most modern Debian packages are managed with GIT repositories, where at least the packaging is versioned in GIT, and releases are usually also marked by GIT tags.","title":"git-buildpackage"},{"location":"dev/gbp/#salsa","text":"A while ago Debian established GitLab as a central hosting service for all GIT repositories. The service is just named Salsa, and is available to everyone to join and contribute. salsa.debian.org","title":"Salsa"},{"location":"dev/gbp/#repository-layouts","text":"","title":"Repository layouts"},{"location":"dev/gbp/#simple-layout","text":"A simple GIT repositories will just contain the debian directory, plus maybe some CI and metadata to build with. In this mode you should find a very simple master or debian/master branch, can just clone it via git . But you will need to take care of downloading and extracting source code. This is also used for the Linux Kernel package , which only does a simple layout, because it is easier to handle in terms of repository sizes.","title":"Simple layout"},{"location":"dev/gbp/#upstream-branches","text":"Many other repositories include the full source code of the upstream project, so it is easier for a developer to have a full working environment. In this usage case, the upstream source code is imported under branch upstream , or even the original upstream GIT repository is used as base, with its branches like master . When importing upstream releases, GIT changes will only show a single commit for the version, with added GIT tag. To have the full file tree, there also will be a debian/master or master branch, which includes the debian directory. Upstream changes are then merged to the Debian packaging branch. As a result, after a GIT clone, you can just start building, and all file changes can be diffed against GIT. The icingaweb2 package repository is a good example for this usage style.","title":"Upstream branches"},{"location":"dev/gbp/#pristine-tar","text":"As optional add-on you often find a pristine-tar branch, this branch is used to store metadata, so the original tarball can be recreated from the GIT branches. Please see man pristine-tar for details.","title":"pristine-tar"},{"location":"dev/gbp/#git-buildpackage_1","text":"Now Debian introduced a small toolkit to work with GIT repositories as source for Debian packages, helping with tasks like: Cloning a GIT repository (with all gbp related branches) Pulling and pushing changes, across multiple branches Building the package while checking with GIT Updating changelog from GIT commits Importing / exporting tarballs of upstream When building a package with gbp , the upstream tarball is usually created automatically.","title":"git-buildpackage"},{"location":"dev/gbp/#examples","text":"Cloning a repository: $ gbp clone https://salsa.debian.org/nagios-team/pkg-icingaweb2 icingaweb2 $ cd icinga2/ You will see that multiple branches have been checked out, and will be updated by pull: $ git branch $ gbp pull Building will create tarball and files in parent directory: $ gbp buildpackage -S $ ls ../icingaweb2* ../icingaweb2_2.7.3-2_amd64.build ../icingaweb2_2.7.3-2.debian.tar.xz ../icingaweb2_2.7.3-2.dsc ../icingaweb2_2.7.3.orig.tar.gz Note: When you want to build a specific version, you can just checkout the respective GIT tag or commit Updating the changelog is very easy with gbp: $ gbp dch -a $ git diff debian/changelog Building and changelog integration can also help with the release changelog, git commits and tags.","title":"Examples"},{"location":"dev/gbp/#further-reading","text":"gbp manual man gbp man gbp-buildpackage man gbp-dch","title":"Further reading"},{"location":"dev/lintian/","text":"Lintian Lintian is a toolkit for linting Debian packages from the contents of the debian directory. Normally Lintian is just run from the extract source, and look for built files. An example for the icingaweb2 package repository . $ gbp buildpackage $ lintian N: Using profile debian/main. N: Starting on group icingaweb2/2.7.3-2 N: Unpacking packages in group icingaweb2/2.7.3-2 N: Finished processing group icingaweb2/2.7.3-2 N: ---- N: Processing changes file icingaweb2 N: (version 2.7.3-2, arch source) ... N: ---- N: Processing source package icingaweb2 N: (version 2.7.3-2, arch source) ... N: ---- N: Processing buildinfo package icingaweb2 N: (version 2.7.3-2, arch source) ... W: icingaweb2 source: changelog-should-mention-nmu W: icingaweb2 source: source-nmu-has-incorrect-version-number 2.7.3-2 P: icingaweb2 source: package-uses-old-debhelper-compat-version 12 P: icingaweb2 source: rules-requires-root-missing P: icingaweb2 source: source-contains-prebuilt-javascript-object public/js/vendor/jquery-3.4.1.min.js P: icingaweb2 source: source-contains-prebuilt-javascript-object public/js/vendor/jquery-migrate-3.1.0.min.js P: icingaweb2 source: source-contains-prebuilt-javascript-object public/js/vendor/jquery.sparkline.min.js N: 1 tag overridden (1 info) For more details and explanations, see the full output: $ lintian --info --display-level pedantic --verbose Further reading man lintian Debian maintainer guide about Lintian","title":"Lintian"},{"location":"dev/lintian/#lintian","text":"Lintian is a toolkit for linting Debian packages from the contents of the debian directory. Normally Lintian is just run from the extract source, and look for built files. An example for the icingaweb2 package repository . $ gbp buildpackage $ lintian N: Using profile debian/main. N: Starting on group icingaweb2/2.7.3-2 N: Unpacking packages in group icingaweb2/2.7.3-2 N: Finished processing group icingaweb2/2.7.3-2 N: ---- N: Processing changes file icingaweb2 N: (version 2.7.3-2, arch source) ... N: ---- N: Processing source package icingaweb2 N: (version 2.7.3-2, arch source) ... N: ---- N: Processing buildinfo package icingaweb2 N: (version 2.7.3-2, arch source) ... W: icingaweb2 source: changelog-should-mention-nmu W: icingaweb2 source: source-nmu-has-incorrect-version-number 2.7.3-2 P: icingaweb2 source: package-uses-old-debhelper-compat-version 12 P: icingaweb2 source: rules-requires-root-missing P: icingaweb2 source: source-contains-prebuilt-javascript-object public/js/vendor/jquery-3.4.1.min.js P: icingaweb2 source: source-contains-prebuilt-javascript-object public/js/vendor/jquery-migrate-3.1.0.min.js P: icingaweb2 source: source-contains-prebuilt-javascript-object public/js/vendor/jquery.sparkline.min.js N: 1 tag overridden (1 info) For more details and explanations, see the full output: $ lintian --info --display-level pedantic --verbose","title":"Lintian"},{"location":"dev/lintian/#further-reading","text":"man lintian Debian maintainer guide about Lintian","title":"Further reading"},{"location":"dev/source/","text":"Source Package Unlike RPM sources a Debian source package consists of multiple files. Downloading a source When you have configured deb-src packages in your APT sources you can download sources. Please make sure you are in a proper working directory, since this downloads multiple files. mkdir debian-packages cd debian-packages/ apt source icingaweb2 You can see APT downloading multiple files from the repository, and verifying them against the Debian Developer Keyring which contains all developer GPG keys, since the source package is signed by the individual developer. Reading package lists... Done NOTICE: 'icingaweb2' packaging is maintained in the 'Git' version control system at: https://salsa.debian.org/nagios-team/pkg-icingaweb2.git Please use: git clone https://salsa.debian.org/nagios-team/pkg-icingaweb2.git to retrieve the latest (possibly unreleased) updates to the package. Need to get 8.180 kB of source archives. Get:1 http://cdn-fastly.deb.debian.org/debian buster/main icingaweb2 2.6.1-1 (dsc) [2.361 B] Get:2 http://cdn-fastly.deb.debian.org/debian buster/main icingaweb2 2.6.1-1 (tar) [8.165 kB] Get:3 http://cdn-fastly.deb.debian.org/debian buster/main icingaweb2 2.6.1-1 (diff) [12,2 kB] Fetched 8.180 kB in 14s (590 kB/s) dpkg-source: info: extracting icingaweb2 in icingaweb2-2.6.1 dpkg-source: info: unpacking icingaweb2_2.6.1.orig.tar.gz dpkg-source: info: unpacking icingaweb2_2.6.1-1.debian.tar.xz Note: While this method is very good for reverse engineering, or rebuilding a package, most workflows today are based on GIT tools . You can also see a notice in the output above. If a download could not be verified, for example when it is from a third party repository or contributor, you can manually extract the downloaded files. (APT will suggest this as well) dpkg-source --no-check -x icingaweb2_2.6.1-1.stretch.dsc Lab: Download icingaweb2 or another source package and extract it. Source package format A few files build the Debian source packages, which is created on build, and uploaded to a repository. package_1.0.0-1.dsc is the meta data description file for the source, which also includes the signature package_1.0.0-1.debian.tar.xz contains the Debian packaging files (whats inside the debian/ directory) package_1.0.0.orig.tar.gz is the original tarball or source distribution from upstream Lab: Have a look in the DSC file and check its content. Versioning The Debian package versions can describe exact state of the package pretty detailed. Simple example: 1.0.0-1 Upstream version: 1.0.0 Debian revision: 1 Complex examples: 2.1.4-2.1+deb8u7 Upstream: 2.1.4 Revision: 2.1 (the dot signals non-maintainer upload) Special: +deb8u7 (Release tag for a stable update) Also there is a \"native\" format, which means that the package does not have a revision since it is a native Debian tool, e.g. devscripts, dpkg. Versions also can have special operators, which are explained in the Debian Policy on Version . Extracted source format In the extracted format, a source package is basically the full program source extracted, plus the debian/ directory. Which contains all definitions and patches for Debian. If the package is not a native package, the dpkg tools need the source tarball to verify and a clean source directory. All work happens in this extracted format, where at least a source package is built from. Various file and directories can be included in this directory, also custom stuff that later is included in packages or just kept for documentation. control Main metadata file which defines: Source name Maintainer Binary packages Dependencies and other relations Descriptions See man deb-control . changelog History of the package, and the released versions. This defines the current version . See man deb-changelog . rules Is a makefile that is called on build to execute the various build steps. For details see man dpkg-buildpackage . The most basic content leaves all for debhelper to figure out. #!/usr/bin/make -f #export DH_VERBOSE=1 %: dh $@ Also see man dpkg-src-rules . source/format Defines which source format to expect, there are legacy versions, but usually this is one of: 3.0 (quilt) 3.0 (native) The word quilt describes a patch tool. compat / debhelper-compat The file compat defines the feature compatibility version for debhelper , this mostly is important when using newer features, or when you want to backport a package to an older Debian release. It just contains the major version, e.g. 9 . In recent versions of debhelper, it is now recommended avoiding compat , and instead use a debhelper-compat build dependency in the control file. Build-Depends: debhelper-compat (= 13) See the debhelper manpage for details. copyright For Debian this is very important, since it describes the license information for all contents of the source and the packaging related files, in a central location. This should be in machine readable format . install Also: <package>.install Describes where to install certain files to the package from various path: Files installed by dh_auto_install under debian/tmp/ From the source directory Similar files exist: dirs - directories to create empty links - symlink to create docs - files to install under /usr/share/doc/<package> post and pre scripts Custom scripts can be put here under: *.post*|*.pre* Those scripts are run during certain steps of dpkg bringing packages onto your target system, like: Stopping and Starting services Configuring users, permissions and other files Sometimes debhelper creates or extend those files, so you might see a ##DEBHELPER## tag in some examples. Please see man dpkg and patches/ Can contain multiple patches that are applied during build. Patches are put here and mentioned in order in the series file. dep3 also describes optional metadata for patches. watch The watch file is a helper file for uscan , to automatically check and download available versions of the software. Debian uses this to check for new versions, but you can often use it to also download a tarball. Other files Other files can exist and vary in format, the are used by a specify debhelper add-on. Lab: Browse the files of your package and find the following information: Current version, who changed the package? What are the build dependencies? What binary packages are built? Build systems debhelper builds on other build systems like: configure/make cmake Golang Python setuptools Ruby Gem etc. Where certain steps are common and often need to be configured: dh_auto_configure which configures the source code for a build (e.g. ./configure or cmake .. -Dxx ) dh_auto_build that runs the build (e.g. make ) dh_auto_install that install files in a target path (e.g. make install ) There are manpages for every debhelper tool under dh_* . Single vs. Multi-Binary If a source only contains a simple binary some path handling is simplified. So files installed by the build tools are directly put into the package. While in a multi-binary layout, the files are put into a tmp/ path, before files a selectively installed by install files. Git tools Nowadays most Debian source definitions are stored in GIT repositories. Nearly all source packages have metadata like this: Vcs-Browser: https://salsa.debian.org/nagios-team/pkg-icingaweb2 Vcs-Git: https://salsa.debian.org/nagios-team/pkg-icingaweb2.git When using GIT there are tools like git-buildpackage that help with checkout, branching, import and changelog. You can checkout this repository, which also includes a branch and tags for upstream. Upstream code is updated with a single commit, and merged to the master branch, which adds files under debian/ . Lab: Have a look on the icingaweb2 repository and its branches and tags See how older versions in the changelog have git hashes","title":"Source Package"},{"location":"dev/source/#source-package","text":"Unlike RPM sources a Debian source package consists of multiple files.","title":"Source Package"},{"location":"dev/source/#downloading-a-source","text":"When you have configured deb-src packages in your APT sources you can download sources. Please make sure you are in a proper working directory, since this downloads multiple files. mkdir debian-packages cd debian-packages/ apt source icingaweb2 You can see APT downloading multiple files from the repository, and verifying them against the Debian Developer Keyring which contains all developer GPG keys, since the source package is signed by the individual developer. Reading package lists... Done NOTICE: 'icingaweb2' packaging is maintained in the 'Git' version control system at: https://salsa.debian.org/nagios-team/pkg-icingaweb2.git Please use: git clone https://salsa.debian.org/nagios-team/pkg-icingaweb2.git to retrieve the latest (possibly unreleased) updates to the package. Need to get 8.180 kB of source archives. Get:1 http://cdn-fastly.deb.debian.org/debian buster/main icingaweb2 2.6.1-1 (dsc) [2.361 B] Get:2 http://cdn-fastly.deb.debian.org/debian buster/main icingaweb2 2.6.1-1 (tar) [8.165 kB] Get:3 http://cdn-fastly.deb.debian.org/debian buster/main icingaweb2 2.6.1-1 (diff) [12,2 kB] Fetched 8.180 kB in 14s (590 kB/s) dpkg-source: info: extracting icingaweb2 in icingaweb2-2.6.1 dpkg-source: info: unpacking icingaweb2_2.6.1.orig.tar.gz dpkg-source: info: unpacking icingaweb2_2.6.1-1.debian.tar.xz Note: While this method is very good for reverse engineering, or rebuilding a package, most workflows today are based on GIT tools . You can also see a notice in the output above. If a download could not be verified, for example when it is from a third party repository or contributor, you can manually extract the downloaded files. (APT will suggest this as well) dpkg-source --no-check -x icingaweb2_2.6.1-1.stretch.dsc Lab: Download icingaweb2 or another source package and extract it.","title":"Downloading a source"},{"location":"dev/source/#source-package-format","text":"A few files build the Debian source packages, which is created on build, and uploaded to a repository. package_1.0.0-1.dsc is the meta data description file for the source, which also includes the signature package_1.0.0-1.debian.tar.xz contains the Debian packaging files (whats inside the debian/ directory) package_1.0.0.orig.tar.gz is the original tarball or source distribution from upstream Lab: Have a look in the DSC file and check its content.","title":"Source package format"},{"location":"dev/source/#versioning","text":"The Debian package versions can describe exact state of the package pretty detailed. Simple example: 1.0.0-1 Upstream version: 1.0.0 Debian revision: 1 Complex examples: 2.1.4-2.1+deb8u7 Upstream: 2.1.4 Revision: 2.1 (the dot signals non-maintainer upload) Special: +deb8u7 (Release tag for a stable update) Also there is a \"native\" format, which means that the package does not have a revision since it is a native Debian tool, e.g. devscripts, dpkg. Versions also can have special operators, which are explained in the Debian Policy on Version .","title":"Versioning"},{"location":"dev/source/#extracted-source-format","text":"In the extracted format, a source package is basically the full program source extracted, plus the debian/ directory. Which contains all definitions and patches for Debian. If the package is not a native package, the dpkg tools need the source tarball to verify and a clean source directory. All work happens in this extracted format, where at least a source package is built from. Various file and directories can be included in this directory, also custom stuff that later is included in packages or just kept for documentation.","title":"Extracted source format"},{"location":"dev/source/#control","text":"Main metadata file which defines: Source name Maintainer Binary packages Dependencies and other relations Descriptions See man deb-control .","title":"control"},{"location":"dev/source/#changelog","text":"History of the package, and the released versions. This defines the current version . See man deb-changelog .","title":"changelog"},{"location":"dev/source/#rules","text":"Is a makefile that is called on build to execute the various build steps. For details see man dpkg-buildpackage . The most basic content leaves all for debhelper to figure out. #!/usr/bin/make -f #export DH_VERBOSE=1 %: dh $@ Also see man dpkg-src-rules .","title":"rules"},{"location":"dev/source/#sourceformat","text":"Defines which source format to expect, there are legacy versions, but usually this is one of: 3.0 (quilt) 3.0 (native) The word quilt describes a patch tool.","title":"source/format"},{"location":"dev/source/#compat-debhelper-compat","text":"The file compat defines the feature compatibility version for debhelper , this mostly is important when using newer features, or when you want to backport a package to an older Debian release. It just contains the major version, e.g. 9 . In recent versions of debhelper, it is now recommended avoiding compat , and instead use a debhelper-compat build dependency in the control file. Build-Depends: debhelper-compat (= 13) See the debhelper manpage for details.","title":"compat / debhelper-compat"},{"location":"dev/source/#copyright","text":"For Debian this is very important, since it describes the license information for all contents of the source and the packaging related files, in a central location. This should be in machine readable format .","title":"copyright"},{"location":"dev/source/#install","text":"Also: <package>.install Describes where to install certain files to the package from various path: Files installed by dh_auto_install under debian/tmp/ From the source directory Similar files exist: dirs - directories to create empty links - symlink to create docs - files to install under /usr/share/doc/<package>","title":"install"},{"location":"dev/source/#post-and-pre-scripts","text":"Custom scripts can be put here under: *.post*|*.pre* Those scripts are run during certain steps of dpkg bringing packages onto your target system, like: Stopping and Starting services Configuring users, permissions and other files Sometimes debhelper creates or extend those files, so you might see a ##DEBHELPER## tag in some examples. Please see man dpkg and","title":"post and pre scripts"},{"location":"dev/source/#patches","text":"Can contain multiple patches that are applied during build. Patches are put here and mentioned in order in the series file. dep3 also describes optional metadata for patches.","title":"patches/"},{"location":"dev/source/#watch","text":"The watch file is a helper file for uscan , to automatically check and download available versions of the software. Debian uses this to check for new versions, but you can often use it to also download a tarball.","title":"watch"},{"location":"dev/source/#other-files","text":"Other files can exist and vary in format, the are used by a specify debhelper add-on. Lab: Browse the files of your package and find the following information: Current version, who changed the package? What are the build dependencies? What binary packages are built?","title":"Other files"},{"location":"dev/source/#build-systems","text":"debhelper builds on other build systems like: configure/make cmake Golang Python setuptools Ruby Gem etc. Where certain steps are common and often need to be configured: dh_auto_configure which configures the source code for a build (e.g. ./configure or cmake .. -Dxx ) dh_auto_build that runs the build (e.g. make ) dh_auto_install that install files in a target path (e.g. make install ) There are manpages for every debhelper tool under dh_* .","title":"Build systems"},{"location":"dev/source/#single-vs-multi-binary","text":"If a source only contains a simple binary some path handling is simplified. So files installed by the build tools are directly put into the package. While in a multi-binary layout, the files are put into a tmp/ path, before files a selectively installed by install files.","title":"Single vs. Multi-Binary"},{"location":"dev/source/#git-tools","text":"Nowadays most Debian source definitions are stored in GIT repositories. Nearly all source packages have metadata like this: Vcs-Browser: https://salsa.debian.org/nagios-team/pkg-icingaweb2 Vcs-Git: https://salsa.debian.org/nagios-team/pkg-icingaweb2.git When using GIT there are tools like git-buildpackage that help with checkout, branching, import and changelog. You can checkout this repository, which also includes a branch and tags for upstream. Upstream code is updated with a single commit, and merged to the master branch, which adds files under debian/ . Lab: Have a look on the icingaweb2 repository and its branches and tags See how older versions in the changelog have git hashes","title":"Git tools"}]}